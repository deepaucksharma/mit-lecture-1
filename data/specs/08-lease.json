{
  "id": "08-lease",
  "title": "Lease State Machine",
  "prerequisites": {
    "concepts": [
      "Write path and Primary's role (Spec 07)",
      "Why having multiple servers think they're Primary is catastrophic (Spec 07)",
      "Network failures and partitions exist (Spec 02, 04)",
      "Distributed coordination challenges"
    ],
    "checkYourself": "Do you understand what a 'Primary' is and why we need one? Can you explain what happens if two servers both think they're in charge of the same chunk?"
  },
  "narrative": "Time is a weapon against chaos. In a world where clocks lie and networks vanish, how do you prevent two servers from both believing they're in charge? You give one server temporary authority—60 seconds of absolute power. Then you take it back. This lease mechanism isn't just clever engineering. It's a peace treaty between distributed nodes, enforced by the relentless march of time. In production: lease extensions piggybacked on 10-second HeartBeat messages, renewal at 50s provides 10s safety margin against network hiccups. Clock drift bounded to ~100ms over 60s with NTP.",
  "crystallizedInsight": "Authority must expire. Time is the only arbiter that never lies—eventually.",
  "firstPrinciples": {
    "distributedConsensus": {
      "impossibilityResult": "FLP theorem: no deterministic consensus with one faulty process in async model",
      "timeoutSolution": "Add time bounds → convert to synchronous model → consensus possible",
      "leaseAsConsensus": "All nodes agree: 'Server X is primary until time T'",
      "safety": "Agreement and validity hold. Liveness requires bounded message delay"
    },
    "timeBasedCoordination": {
      "lamportClocks": "Logical time provides ordering but not duration. Physical time needed for leases",
      "clockSynchronization": "NTP provides ~1ms accuracy over LAN, ~10ms over WAN",
      "driftBound": "Typical quartz crystal: 50ppm drift = 4.3s/day = 180ms/hour",
      "safetyMargin": "Lease_duration > 2 × (max_drift + max_network_delay + processing_time)"
    },
    "formalModel": {
      "leaseValidity": "∀t: |{s: s believes it's primary at t}| ≤ 1",
      "timeWindow": "Primary(s,t) ↔ ∃grant_time: grant_time ≤ t < grant_time + lease_duration",
      "gracePeriod": "New_grant_time > old_expiry + 2×max_clock_skew",
      "livenessCondition": "∃t_future: ∃s: Primary(s, t_future) (eventually someone becomes primary)"
    },
    "probabilisticAnalysis": {
      "renewalFailureProbability": "P(fail) = P(network_fail) × P(timeout < renewal_attempt)",
      "expectedUptime": "MTTF = lease_duration / P(renewal_failure)",
      "optimalRenewalTime": "t_renew* = lease_duration - sqrt(2 × lease_duration × network_RTT)",
      "withRetries": "P(fail_with_retries) = P(fail)^n where n = floor((lease_duration - t_renew) / retry_interval)"
    }
  },
  "layout": {
    "type": "state"
  },
  "nodes": [
    {
      "id": "NoLease",
      "type": "state",
      "label": "No Lease",
      "metadata": {
        "description": "No primary assigned"
      }
    },
    {
      "id": "Granting",
      "type": "state",
      "label": "Granting Lease",
      "metadata": {
        "description": "Master granting lease"
      }
    },
    {
      "id": "Active",
      "type": "state",
      "label": "Lease Active",
      "metadata": {
        "description": "Primary has valid lease"
      }
    },
    {
      "id": "Expiring",
      "type": "state",
      "label": "Lease Expiring",
      "metadata": {
        "description": "Near expiration, renewing"
      }
    },
    {
      "id": "Expired",
      "type": "state",
      "label": "Lease Expired",
      "metadata": {
        "description": "Lease timed out"
      }
    },
    {
      "id": "Revoking",
      "type": "state",
      "label": "Revoking",
      "metadata": {
        "description": "Master revoking lease"
      }
    }
  ],
  "edges": [
    {
      "id": "grant",
      "from": "NoLease",
      "to": "Granting",
      "label": "Client requests write"
    },
    {
      "id": "granted",
      "from": "Granting",
      "to": "Active",
      "label": "Lease granted (60s)"
    },
    {
      "id": "renew-start",
      "from": "Active",
      "to": "Expiring",
      "label": "50s elapsed"
    },
    {
      "id": "renewed",
      "from": "Expiring",
      "to": "Active",
      "label": "Extension granted"
    },
    {
      "id": "timeout",
      "from": "Expiring",
      "to": "Expired",
      "label": "No response (10s)"
    },
    {
      "id": "expire",
      "from": "Active",
      "to": "Expired",
      "label": "60s elapsed"
    },
    {
      "id": "expired-done",
      "from": "Expired",
      "to": "NoLease",
      "label": "Wait for safety"
    },
    {
      "id": "revoke-start",
      "from": "Active",
      "to": "Revoking",
      "label": "Master revokes"
    },
    {
      "id": "revoked",
      "from": "Revoking",
      "to": "NoLease",
      "label": "Revocation complete"
    }
  ],
  "scenes": [
    {
      "id": "normal-flow",
      "title": "Normal Renewal",
      "overlays": ["normal-renewal"]
    },
    {
      "id": "network-partition",
      "title": "Network Partition",
      "overlays": ["partition-scenario"]
    },
    {
      "id": "clock-drift",
      "title": "Clock Drift Safety",
      "overlays": ["clock-analysis"]
    }
  ],
  "overlays": [
    {
      "id": "normal-renewal",
      "caption": "The Happy Path—Renewal Before Expiry",
      "diff": {
        "add": {
          "nodes": [
            {
              "id": "renewal-note",
              "type": "note",
              "label": "At 50 seconds:\\n- Primary asks for extension\\n- Master grants 60 more seconds\\n- System hums along\\n- No one notices"
            }
          ]
        },
        "highlight": {
          "edgeIds": ["renew-start", "renewed"]
        }
      }
    },
    {
      "id": "partition-scenario",
      "caption": "The Nightmare—Network Split",
      "diff": {
        "add": {
          "nodes": [
            {
              "id": "partition-note",
              "type": "note",
              "label": "Primary's view: 'Master ignores me!'\\nMaster's view: 'Primary is dead!'\\nTruth: Network cable cut\\n\\nLease expires. Primary MUST stop.\\nMaster waits 2×lease before new grant.\\nSplit-brain impossible."
            }
          ]
        },
        "highlight": {
          "edgeIds": ["timeout", "expired-done"]
        }
      }
    },
    {
      "id": "clock-analysis",
      "caption": "Clock Drift—The Silent Killer",
      "diff": {
        "add": {
          "nodes": [
            {
              "id": "clock-note",
              "type": "note",
              "label": "Master's clock: 60.000s\\nPrimary's clock: 59.900s\\nDrift: 100ms over 60s\\n\\nSafety margin: 10 seconds\\nDrift margin: 100ms\\nTotal buffer: Plenty\\n\\nThis is why 60s, not 6s"
            }
          ]
        },
        "highlight": {
          "nodeIds": ["Active"]
        }
      }
    },
    {
      "id": "revocation-emergency",
      "caption": "Emergency Revocation",
      "diff": {
        "add": {
          "nodes": [
            {
              "id": "revoke-note",
              "type": "note",
              "label": "Master needs to move chunk\\nCan't wait 60 seconds\\nSends revocation message\\nPrimary surrenders immediately\\nOr Master waits for expiration"
            }
          ]
        },
        "highlight": {
          "edgeIds": ["revoke-start", "revoked"]
        }
      }
    }
  ],
  "contracts": {
    "invariants": [
      "At most one primary per chunk at any time (lease protocol ensures single writer, prevents split-brain)",
      "Lease duration (60s) > 2 × max clock drift (~100ms) + network delays (safety margin = 10s)",
      "Grace period after expiration before new grant (Master waits for old lease to expire before granting new)"
    ],
    "guarantees": [
      "No split-brain possible (time-based expiry ensures old primary stops before new one starts)",
      "Primary authority is time-bounded (60s initial grant, renewed via HeartBeat at 50s)",
      "Clean handoff on planned transitions (revocation message for immediate handoff, otherwise wait for expiry)"
    ],
    "caveats": [
      "Network delays can cause premature lease loss (if renewal packet delayed >10s, lease expires)",
      "Clock skew affects safety margins (50ppm drift = 4.3s/day, requires NTP synchronization)",
      "In-flight operations during transition may fail (client retries with new primary after lease transfer)"
    ]
  },
  "drills": [
    {
      "id": "drill-why-time",
      "type": "analyze",
      "prompt": "Why use time-based leases instead of explicit 'I quit' messages from the Primary?",
      "thoughtProcess": [
        "Explicit messages sound cleaner: Primary says 'I'm done', Master appoints new one",
        "But what if the Primary crashes? No goodbye message.",
        "What if network partitions? Message never arrives.",
        "Master waits forever for a message that will never come",
        "Time-based leases handle the worst case: silence",
        "Silence means expired, not 'waiting for confirmation'",
        "60 seconds pass, old Primary's authority MUST end",
        "Even if Primary doesn't know, even if network is dead",
        "Time is the ultimate timeout"
      ],
      "insight": "In distributed systems, you can't rely on hearing 'no'. Silence must have a meaning."
    },
    {
      "id": "drill-60-seconds",
      "type": "apply",
      "prompt": "Walk through the math: Why exactly 60 seconds? Why not 10 or 600?",
      "scenario": "Typical server clock drift: 100ms/min, Network RTT: 1-5ms, Heartbeat interval: 10s",
      "thoughtProcess": [
        "Too short (10s): Constant renewal chatter, minor hiccups cause failures",
        "- Clock drift over 10s: 16ms",
        "- Heartbeat might miss one interval: 10s wait",
        "- Barely any safety margin",
        "Too long (600s): Primary keeps authority for 10 minutes during failures",
        "- Failed Primary blocks writes for 10 minutes",
        "- Users notice. Tickets get filed. People get paged.",
        "Just right (60s):",
        "- Clock drift over 60s: 100ms (0.16% error)",
        "- Renewal at 50s gives 10s buffer",
        "- If Primary dies, 60s until recovery starts",
        "- 1 minute is long enough to ignore blips, short enough to recover from crashes"
      ],
      "insight": "The right timeout balances false positives (noise) against false negatives (outages)"
    },
    {
      "id": "drill-split-brain",
      "type": "create",
      "prompt": "You're the old Primary, partitioned from the Master. Your lease expires. A client asks you to write. What do you do?",
      "thoughtProcess": [
        "You haven't heard from Master in 60 seconds",
        "Your local clock says: lease expired",
        "But wait... what if my clock is slow?",
        "Or what if the network just healed and I'm about to reconnect?",
        "The temptation: 'Just this one write, what could go wrong?'",
        "NO. The lease is expired. You are no longer Primary.",
        "You MUST reject the write.",
        "Tell the client: 'I'm not Primary anymore. Ask the Master.'",
        "Even if you're wrong, even if it seems wasteful",
        "Because the alternative is two Primaries, writing different data",
        "That way lies madness and data corruption"
      ],
      "insight": "When your authority expires, surrender it. Pride kills distributed systems."
    },
    {
      "id": "drill-clock-skew-attack",
      "type": "analyze",
      "prompt": "An attacker can skew the Primary's clock. How much skew is needed to cause split-brain?",
      "thoughtProcess": [
        "Master grants lease: timestamp T",
        "Master's view: expires at T+60s",
        "Normal Primary's view: expires at T+60s (roughly)",
        "Attacker speeds up Primary's clock by 10 minutes",
        "Primary's view: 'Only 5 seconds have passed'",
        "Master's view: '60 seconds passed, lease expired'",
        "Master grants new lease to different server",
        "Now TWO servers think they're Primary!",
        "But wait... GFS has a grace period",
        "Master waits 2×lease (120s) before granting new lease",
        "So attacker needs to slow clock by... impossible",
        "Actually: speeding up Primary's clock makes it expire FASTER",
        "Slowing it down... Primary holds on longer, but eventually its lease expires",
        "The vulnerability: if attacker controls BOTH Master and Primary clocks"
      ],
      "insight": "Time-based coordination assumes bounded clock drift. Break that assumption, break the system."
    }
  ],
  "assessmentCheckpoints": [
    {
      "id": "understand-lease-purpose",
      "competency": "I understand that leases prevent split-brain scenarios",
      "checkYourself": "Can you explain what happens if two servers think they're Primary?",
      "mastery": "You see leases as a coordination mechanism, not just a performance optimization"
    },
    {
      "id": "understand-time-based-safety",
      "competency": "I know why time-based expiration is more robust than explicit revocation",
      "checkYourself": "What if the network fails during revocation?",
      "mastery": "You design systems that work even when communication fails"
    },
    {
      "id": "understand-clock-assumptions",
      "competency": "I see how clock drift affects lease safety",
      "checkYourself": "How much drift can the system tolerate?",
      "mastery": "You account for clock skew in every distributed protocol"
    },
    {
      "id": "understand-grace-periods",
      "competency": "I know why the Master waits after lease expiry before granting new leases",
      "checkYourself": "Why not grant immediately at expiration?",
      "mastery": "You build safety margins into coordination protocols"
    }
  ],
  "advancedConcepts": {
    "alternativeCoordinationMechanisms": {
      "fencing": {
        "principle": "Include monotonic token with lease. Storage rejects old tokens",
        "advantage": "Prevents delayed operations from expired leases",
        "implementation": "Every lease includes epoch number, storage tracks highest seen",
        "example": "Chubby, ZooKeeper session IDs"
      },
      "heartbeats": {
        "principle": "Continuous liveness proof instead of time-based expiry",
        "advantage": "Faster failure detection, no clock dependency",
        "disadvantage": "Higher network overhead, what if heartbeat delayed?",
        "hybrid": "Heartbeats + lease as backup timeout"
      },
      "consensusBasedLeader": {
        "principle": "Use Raft/Paxos to elect leader, no explicit lease",
        "advantage": "Handles Byzantine failures, stronger consistency",
        "disadvantage": "Higher complexity, more network rounds",
        "example": "etcd, Consul, CockroachDB"
      },
      "lockFreeCoordination": {
        "principle": "CAS operations, no designated primary",
        "advantage": "No coordination overhead, natural load balancing",
        "disadvantage": "Conflict resolution complexity, no total order",
        "example": "Cassandra's LWT, DynamoDB conditional writes"
      }
    },
    "clockSynchronizationDepth": {
      "ntpHierarchy": "Stratum 0 (atomic) → Stratum 1 (GPS) → Stratum 2 (datacenter) → Stratum 3 (servers)",
      "truetime": {
        "google": "GPS + atomic clocks in each datacenter",
        "guarantee": "Returns interval [earliest, latest] containing true time",
        "precision": "~7ms uncertainty (ε), enables Spanner's consistency"
      },
      "hybridLogicalClocks": {
        "principle": "Combine physical time + logical counter",
        "formula": "HLC = max(physical_time, highest_seen_HLC) + counter",
        "property": "Tracks causality AND bounded drift from physical time"
      },
      "atomicBroadcast": {
        "principle": "Hardware-assisted time sync via PTP (Precision Time Protocol)",
        "accuracy": "Sub-microsecond over LAN with hardware timestamps",
        "requirement": "PTP-capable NICs and switches"
      }
    },
    "leaseOptimizationStrategies": {
      "adaptiveDuration": {
        "principle": "Adjust lease time based on load and failure rate",
        "shortLeases": "During high contention or maintenance",
        "longLeases": "During stable operation",
        "formula": "duration = base_time × (1 + stability_score)"
      },
      "hierarchicalLeases": {
        "principle": "Master grants lease to rack leader, rack leader sub-leases to servers",
        "benefit": "Reduces Master load, faster local coordination",
        "risk": "Cascading failures if rack leader dies"
      },
      "stickyLeases": {
        "principle": "Prefer renewing with same server over reassignment",
        "benefit": "Better cache locality, fewer cold starts",
        "implementation": "Bias renewal probability: P(same) = 0.9, P(new) = 0.1"
      },
      "preemptiveRenewal": {
        "principle": "Renew based on predicted need, not fixed schedule",
        "prediction": "ML model: P(need_lease_next_60s) based on access patterns",
        "benefit": "Reduces unnecessary renewals during idle periods"
      }
    },
    "failureModesAndMitigation": {
      "grayFailure": {
        "symptom": "Primary responds to some but not all requests",
        "detection": "Multiple observers vote on liveness",
        "mitigation": "Require quorum of heartbeat receivers to maintain lease"
      },
      "clockJump": {
        "cause": "NTP correction, VM migration, kernel bug",
        "symptom": "Lease expires instantly or extends indefinitely",
        "mitigation": "Monotonic clocks for duration, wall clock for deadlines"
      },
      "networkAsymmetry": {
        "symptom": "Can send but not receive (or vice versa)",
        "problem": "Primary sends data but can't receive renewal",
        "solution": "Bidirectional health checks, both directions must work"
      },
      "byzantinePrimary": {
        "symptom": "Malicious primary claims lease forever",
        "solution": "Cryptographic leases: signature with timestamp, verifiable expiry"
      }
    },
    "mathematicalFoundations": {
      "markovModel": {
        "states": "{Active, Renewing, Expired, Failed}",
        "transitionMatrix": "P where P[i,j] = probability of state i→j",
        "steadyState": "π where πP = π, gives long-term state distribution",
        "availability": "π[Active] + π[Renewing] = system availability"
      },
      "queuingAnalysis": {
        "renewalQueue": "M/M/1 with arrival rate λ = num_chunks/lease_duration",
        "serviceTime": "μ = 1/renewal_processing_time",
        "stability": "ρ = λ/μ < 1 required for stable operation",
        "responseTime": "W = 1/(μ - λ) including queue wait"
      },
      "gameTheory": {
        "competingPrimaries": "Nash equilibrium: both respect leases",
        "deviation": "Ignoring lease → data corruption → both lose",
        "mechanism": "Lease protocol is incentive-compatible"
      },
      "controlTheory": {
        "plant": "Distributed system state",
        "controller": "Lease grant/revoke decisions",
        "feedback": "Heartbeats and renewal requests",
        "stability": "Lyapunov function: V = Σ(time_to_expiry), decreases unless renewed"
      }
    },
    "productionConsiderations": {
      "monitoring": {
        "metrics": "Lease expiry rate, renewal latency, grace period violations",
        "alerts": "Renewal failure rate > 0.1%, clock drift > 100ms",
        "dashboards": "Lease timeline view, primary churn rate, per-chunk lease history"
      },
      "testing": {
        "chaosEngineering": "Randomly expire leases, inject clock skew",
        "jepsen": "Formal testing of lease invariants under partition",
        "timeTravelTesting": "Fast-forward clocks to test expiry handling"
      },
      "debugging": {
        "leaseTable": "In-memory view of all active leases with expiry times",
        "eventLog": "Every grant, renewal, expiry, revocation with timestamps",
        "clockAudit": "Compare clock readings across all servers, flag outliers"
      },
      "operationalLevers": {
        "emergencyRevoke": "Admin command to force lease expiry",
        "freezeGrants": "Temporarily stop granting new leases during incidents",
        "extendAll": "Batch extend all leases during maintenance"
      }
    },
    "theoreticalExtensions": {
      "byzantineLeases": {
        "problem": "Malicious nodes may ignore lease expiry",
        "solution": "Threshold signatures: k-of-n must agree on lease grant",
        "implementation": "BFT consensus for lease management"
      },
      "quantumLeases": {
        "concept": "Lease exists in superposition until observed",
        "mechanism": "Quantum entanglement for instant lease revocation",
        "status": "Theoretical only, requires quantum network"
      },
      "probabilisticLeases": {
        "idea": "Lease validity decreases probabilistically over time",
        "formula": "P(valid) = e^(-λt) where λ = 1/expected_lease_duration",
        "benefit": "Natural load balancing as validity decreases"
      },
      "socialLeases": {
        "principle": "Reputation-based lease duration",
        "formula": "duration = base × reputation_score",
        "evolution": "Good actors get longer leases, bad actors get shorter"
      }
    },
    "historicalContext": {
      "dekkerAlgorithm": "1965: First mutual exclusion without hardware support",
      "lamportBakery": "1974: Ticket-based ordering, inspiration for lease numbers",
      "ricartAgrawala": "1981: Distributed mutual exclusion using logical clocks",
      "grayChubby": "2006: Lock service with leases, influenced GFS design",
      "raftConsensus": "2014: Simplified Paxos with leader leases for reads"
    }
  }
}
